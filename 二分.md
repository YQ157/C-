# 二分
二分是常见的查找方式，可以类比高中数学二分法找函数零点。
C++中提供了```lower_bound();upper_bound()```两个函数。 [点击查看用法](https://github.com/YQ157/C-plus-plus/blob/main/%E4%B8%80%E4%BA%9BSTL%E7%9A%84%E5%87%BD%E6%95%B0.md#%E6%9F%A5%E6%89%BE)

但是上述函数只能用于查找，不能满足常见的二分判定答案的要求，所以二分是必须掌握的基础算法之一。

整数二分的难点在于边界处理，处理不好可能死循环或者漏掉数据。
具体不介绍，这里先给出**整数二分**的模板。

常见的有多种模板，这里给出形式最优美的一种。
## 模板介绍
这种二分方式的特点是，最终 $l$ 和 $r$ 会相交于答案处\(如果存在\)，~（而且对于无解的情况，可以很自然的处理，可以不掌握，下面会提到）~，唯一的一点缺憾是它由两种形式组成。
## 模板
### 大于等于
下列代码在区间 $\[1,n\]$ 中查找大于等于 $x$ 的最小的数。
将区间分成 $\[l,mid\]$ 和 $\[mid+1,r\]$ 两个区间，不重不漏。
```cpp
int l=1,r=n;
while(l<r)
{
  int mid=l+r>>1;
  if(a[mid]<x)l=mid+1;//如果答案不在左边，而且mid不是答案 
  else r=mid;
}
cout<<a[r]<<'\n';//最终答案在a[l]=a[r]处
//正常题目这里可以判断一下找到的答案对不对，如果不对说明无解
```
### 小于等于
下列代码在区间 $\[1,n\]$ 中查找小于等于 $x$ 的最大的数。
将区间分成 $\[l,mid-1\]$ 和 $\[mid,r\]$ 两个区间，不重不漏。
```cpp
int l=1,r=n;
while(l<r)
{
  int mid=l+r+1>>1;
  if(a[mid]<=x)l=mid;//如果这个数小于等于x，显然答案在 [mid,r] 
  else r=mid-1;//不然肯定在另一个区间
}
cout<<a[r]<<'\n';//最终答案在a[l]=a[r]处
```
### 解释
两种形式的区别在于 $mid$ 是否 $+1$ ，这是因为边界问题，因为 ```int mid=l+r>>1;l=mid;```时，如果 $l=3,r=4$ ,计算后 $l$ 仍等于 3 ，就死循环了。
用到二分时，代码中先打 ```int mid=l+r>>1;```，再思考区间怎么划分，根据mid是否有可能是答案来划分区间，如果mid可能是，那么更新区间后mid仍要在区间内。如果代码写了```l=mid```，那么对应的```mid=l+r+1>>1```，否则没有 $+1$ 。区间划分不重不漏，显然```l=mid;```那么```r=mid-1```，反之```l=mid+1```则```r=mid```而且 mid 没有 $+1$ 。
### 无解情况处理
观察可以发现，```int mid=l+r>>1```不可能让mid直接等于r（除非l==r），利用这个性质，我们把 $\[1,n\]$ 扩大到 \[1,n+1\] ，如果题目又要求如果无解输出 $-1$ , 那么事先令 a\[n+1\]，如果在 \[1,n\]的有效范围内没能找到答案，没有比 x 大的数，那么最终l=r=n+1。
就可以有解无解都统一直接打印 a\[r\] ，省去判断。
同理，```int mid=l+r+1>>1```不可能让mid直接等于l（除非l==r），把 $\[1,n\]$ 扩大到 \[0,n\] 即可。
